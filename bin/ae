#!/usr/bin/env python

import abc
import os
import os.path
import re
import sys
import yaml

class SchematicHandler:
    def __init__(self, schematic):
        self.schematic = schematic
        self.name = schematic['name']
        self.cache_dir = os.path.join(os.path.abspath(os.path.curdir), '.ae')
        self.root_dir = os.path.join(self.cache_dir, 'root')

    def bootstrap(self):
        if not os.path.isdir(self.cache_dir):
            os.mkdir(self.cache_dir)
        os.putenv('SCHEMATIC_INSTALL_PREFIX', self.root_dir)
        os.putenv('SCHEMATIC_PARALLELISM', '1')
        return self

    def checkout(self):
        print '>> checkout'
        url = self.schematic['source']['url']
        branch = self.schematic['source']['ref'] or 'master'
        repos_dir = os.path.join(self.cache_dir, 'repos')
        self.checkout_dir = os.path.join(repos_dir, self.name)

        if not os.path.isdir(repos_dir):
            os.mkdir(repos_dir)

        if not os.path.isdir(self.checkout_dir):
            command = "git clone --depth 1 %s %s" % (url, self.checkout_dir)
        else:
            command = "cd %s && git fetch" % (self.checkout_dir)

        self.__readpipe__(os.popen(command))
        self.__readpipe__(os.popen("cd %s && git checkout origin/%s" % (self.checkout_dir, branch)))
        return self

    def prepare(self):
        print '>> prepare'
        steps = self.schematic['prepare'] or []
        self.__run_steps__(steps)
        return self

    def build(self):
        print '>> build'
        steps = self.schematic['build'] or []
        self.__run_steps__(steps)
        return self

    def install(self):
        print '>> install'
        steps = self.schematic['install'] or []
        self.__run_steps__(steps)
        return self

    def __run_steps__(self, steps):
        for s in steps:
            self.__readpipe__(os.popen("cd %s && %s" % (self.checkout_dir, s)))

    def __readpipe__(self, pipe):
        while True:
            line = pipe.readline()
            if not line:
                break
            sys.stdout.write("[%s] %s" % (self.name, line))
            sys.stdout.flush()


class FileCatalog:
    def __init__(self, uri):
        self.uri = uri
        self.schematics = {}

    def load(self):
        path = re.split('file:\/\/', self.uri)[1]
        catalog_dir = os.path.join(path, 'catalog')
        if os.path.isdir(catalog_dir):
            for schematic in os.listdir(catalog_dir):
                if not schematic.endswith('.yaml'):
                    continue
                name = re.sub('\.yaml', '', schematic)
                schematic = os.path.join(catalog_dir, schematic)
                self.schematics[name] = yaml.load(file(schematic))

    def has_schematic(self, schematic):
        if self.schematics.has_key(schematic):
            return self.schematics[schematic]
        return None

    def __str__(self):
        return "FileCatalog(%s)" % self.uri

def install():
    if not os.path.isfile('schematics.yaml'):
        return 1
    schematics = yaml.load(file('schematics.yaml'))

    catalogs = []
    for catalog in schematics['catalogs']:
        c = FileCatalog(catalog)
        c.load()
        catalogs.append(c)

    graph = {}
    todo = {}
    for schematic in schematics['schematics']:
        for catalog in catalogs:
            s = catalog.has_schematic(schematic)
            if s:
                todo[schematic] = SchematicHandler(s)

    # XXX: really should be walking the dependncy graph first
    for schematic in todo:
        print "Should install %s" % schematic
        handler = todo[schematic]
        handler.bootstrap().checkout().prepare().build().install()
    return 0


def main():
    if len(sys.argv) > 1:
        if sys.argv[1] == 'install':
            sys.exit(install())
    else:
        print "Welcome to the Analytical Engine"


if __name__ == '__main__':
    main()
