#!/usr/bin/env python

import abc
import os
import os.path
import re
import sys
import yaml

CACHE_DIR = os.path.join(os.path.abspath(os.path.curdir), '.ae')
ROOT_DIR = os.path.join(CACHE_DIR, 'root')
# We'll need these everywhere basically
os.putenv('SCHEMATIC_INSTALL_PREFIX', ROOT_DIR)
os.putenv('SCHEMATIC_PARALLELISM', '1')

class SchematicHandler:
    def __init__(self, schematic):
        self.schematic = schematic
        self.name = schematic['name']

    def bootstrap(self):
        if not os.path.isdir(CACHE_DIR):
            os.mkdir(CACHE_DIR)
        return self

    def checkout(self):
        print '>> checkout'
        url = self.schematic['source']['url']
        branch = self.schematic['source']['ref'] or 'master'
        repos_dir = os.path.join(CACHE_DIR, 'repos')
        self.checkout_dir = os.path.join(repos_dir, self.name)

        if not os.path.isdir(repos_dir):
            os.mkdir(repos_dir)

        if not os.path.isdir(self.checkout_dir):
            command = "git clone --depth 1 %s %s" % (url, self.checkout_dir)
        else:
            command = "cd %s && git fetch" % (self.checkout_dir)

        self.__readpipe__(os.popen(command))
        self.__readpipe__(os.popen("cd %s && git checkout origin/%s" % (self.checkout_dir, branch)))
        return self

    def prepare(self):
        print '>> prepare'
        steps = self.schematic['prepare'] or []
        self.__run_steps__(steps)
        return self

    def build(self):
        print '>> build'
        steps = self.schematic['build'] or []
        self.__run_steps__(steps)
        return self

    def install(self):
        print '>> install'
        steps = self.schematic['install'] or []
        self.__run_steps__(steps)
        return self

    def __run_steps__(self, steps):
        for s in steps:
            self.__readpipe__(os.popen("cd %s && %s" % (self.checkout_dir, s)))

    def __readpipe__(self, pipe):
        while True:
            line = pipe.readline()
            if not line:
                break
            sys.stdout.write("[%s] %s" % (self.name, line))
            sys.stdout.flush()


class FileCatalog:
    def __init__(self, uri):
        self.uri = uri
        self.schematics = {}

    def load(self):
        path = re.split('file:\/\/', self.uri)[1]
        catalog_dir = os.path.join(path, 'catalog')
        if os.path.isdir(catalog_dir):
            for schematic in os.listdir(catalog_dir):
                if not schematic.endswith('.yaml'):
                    continue
                name = re.sub('\.yaml', '', schematic)
                schematic = os.path.join(catalog_dir, schematic)
                self.schematics[name] = yaml.load(file(schematic))

    def has_schematic(self, schematic):
        if self.schematics.has_key(schematic):
            return self.schematics[schematic]
        return None

    def __str__(self):
        return "FileCatalog(%s)" % self.uri

def install():
    if not os.path.isfile('schematics.yaml'):
        return 1
    schematics = yaml.load(file('schematics.yaml'))

    catalogs = []
    for catalog in schematics['catalogs']:
        c = FileCatalog(catalog)
        c.load()
        catalogs.append(c)

    graph = {}
    todo = {}
    for schematic in schematics['schematics']:
        for catalog in catalogs:
            s = catalog.has_schematic(schematic)
            if s:
                todo[schematic] = SchematicHandler(s)

    # XXX: really should be walking the dependncy graph first
    for schematic in todo:
        print "Installing schematic %s" % schematic
        handler = todo[schematic]
        handler.bootstrap().checkout().prepare().build().install()
    return 0

def run():
    if len(sys.argv) < 3:
        print "Must specify a command to run"
        return -1
    env = {}
    for e in os.environ:
        env[e] = os.environ[e]
    # Put our own ROOT_DIR bits in the path first to make sure `ae run` can execute
    # schematic installed binaries
    env['PATH'] = ':'.join([os.path.join(ROOT_DIR, 'bin'), os.environ['PATH']])

    project_path = os.path.join(ROOT_DIR, 'lib', 'gnat')
    key = 'ADA_PROJECT_PATH'

    if os.environ.has_key(key):
        env[key] = ':'.join([project_path, os.environ[key]])
    else:
        env[key] = project_path

    key = 'GPR_PROJECT_PATH'
    if os.environ.has_key(key):
        env[key] = ':'.join([project_path, os.environ[key]])
    else:
        env[key] = project_path

    key = 'ADA_INCLUDE_PATH'

    include_path = os.path.join(ROOT_DIR, 'include')
    if os.environ.has_key(key):
        env[key] = ':'.join([include_path, os.environ[key]])
    else:
        env[key] = include_path
    return os.execvpe(sys.argv[2], sys.argv[2:], env)


def main():
    if len(sys.argv) > 1:
        if sys.argv[1] == 'install':
            sys.exit(install())
        if sys.argv[1] == 'run':
            sys.exit(run())
    else:
        print "Welcome to the Analytical Engine"


if __name__ == '__main__':
    main()
